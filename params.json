{
  "name": "Tutoriel-fullstack-js-6-serveur",
  "tagline": "Tutoriel Fullstack JavaScript - Chapitre 6 - Serveur avec Express",
  "body": "# Le serveur\r\n\r\nJusqu'à maintenant nos applications de liste \"à faire\", se remettent à zéro chaque fois que nous rafraîchissons la page. Tout ce que nous y ajoutons ne reste en mémoire que pour la session courante. Si nous voulons revenir dessus plus tard, ou la partager avec d'autres, il nous faut garder les données sur un serveur.\r\n\r\nDans ce chapitre nous allons utiliser un serveur [Express](http://expressjs.com/) et une base de données [SQLite](https://www.sqlite.org/).\r\n\r\nExpress est un serveur écrit en javascript. Il existe une multitide d'architectures possibles pour les serveurs. L'intéret de l'écrire en javascript est qu'on utilise le même language côté serveur que côté client.\r\n\r\nJ'ai choisi d'utiliser SQLite pour ce tutoriel parce qu'il n'y a pas besoin de l'installer sur votre machine. Il est évidemment possible d'utiliser n'importe quelle base de données avec Express. Si vous avez déjà une base Postgres, jetez un coup d'oeil à la librairie [pg](https://www.npmjs.com/package/pg). Si vous utilisez MongoDB, il y a [mongoose](https://www.npmjs.com/package/mongoose).\r\n\r\n## Une api REST\r\n\r\nLa communication entre les applications et la base de données se fera par le biais d'une api [REST](https://fr.wikipedia.org/wiki/Representational_State_Transfer). Pour faire court, disons que le serveur envoit les données à l'application. Quand une modification a lieu dans l'application, celle-ci l'envoit au serveur qui modifie la base de donnée et renvoit les données modifiées.\r\n\r\n## Mise en place\r\n\r\nCréez un nouveau dossier ```6.serveur```, initialisez NPM et téléchargez les librairies ```express``` (le serveur), ```body-parser``` (pour que le serveur puisse lire ce qui lui est envoyé) et ```sqlite3``` (qui fera la liaison avec la base de données).\r\n\r\n```\r\n$ npm init\r\n$ npm install express body-parser sqlite3\r\n```\r\n\r\n## La base de données\r\n\r\n### Création de la base et de la table\r\n\r\nPour commencer nous allons créer un fichier qui met en place la base de données avec une table ```afaire```.\r\n\r\nCréez un fichier ```mise-en-place-bd.js```\r\n\r\n```\r\n// création de la base si elle n'existe pas\r\n// sinon ouverture de la base\r\nvar db = new sqlite3.Database('bd.sqlite')\r\n\r\n// la requête SQL pour créer une table avec trois champs\r\n// * id : l'identifiant unique\r\n// * text : le texte décrivant la chose à faire\r\n// * fait : un booléen (vrai ou faux) \r\ndb.run('CREATE TABLE afaire (id INTEGER PRIMARY KEY AUTOINCREMENT, text VARCHAR, fait BOOLEAN)')\r\n\r\n// fermer la base quand la table a été créée\r\ndb.close()\r\n\r\n// nous informer que ça a marché\r\nconsole.log('la base a été créée')\r\n```\r\n\r\nAjoutez un scripte ```init-bd``` dans ```package.json``` qui efface la base de donnée si elle existe déjà puis la crée à nouveau.\r\n\r\n```\r\n\"init-bd\": \"rm bd.sqlite | node mise-en-place-bd\"\r\n```\r\n\r\nLancez le scripte dans le terminal:\r\n\r\n```\r\n$ npm run init-bd\r\n```\r\n\r\nUn nouveau fichier a été créé dans le dossier ```6.serveur```: ```bd.sqlite```.\r\n\r\n### Fonctions pour accéder à la base\r\n\r\nCréez un dossier ```lib``` et à l'intérieur de celui-ci un dossier ```bd```.\r\n\r\n#### Requêtes\r\n\r\nDans ce dossier créez un fichier ```a-faire.js``` qui gérera les opérations que nous souhaitons faire sur la table ```afaire``` ainsi qu'un autre dossier ```a-faire``` ou on mettra le détail de ces opérations.\r\n\r\nNous avons quatre type de requêtes à créer:\r\n* Ajouter une nouvelle ligne\r\n* Lire toutes les lignes\r\n* Modifier une ligne\r\n* Supprimer des lignes\r\n\r\nPour chacune d'entre elles nous créons un fichier dans le dossier ```lib/bd/a-faire``` qui sera référencée dans ```lib/bd/a-faire.js```.\r\n\r\n**ajouter.js**\r\n\r\n```\r\nvar sqlite3 = require('sqlite3')\r\n\r\nmodule.exports = function(d, callback) {\r\n\r\n// l'argument \"d\" ce sont les données\r\n// nous créons un objet avec \"text\" et \"fait\"\r\n var obj = {\r\n  $text: d.text,\r\n  $fait: d.fait\r\n }\r\n\r\n// ouverture de la base\r\n var db = new sqlite3.Database('bd.sqlite')\r\n\r\n// .serialize implique que les requêtes seront faites l'une après l'autre\r\n db.serialize(function() {\r\n\r\n// ajout de la ligne\r\n  db.run('INSERT INTO afaire (text, fait) VALUES ($text, $fait)', obj)\r\n\r\n// retrait de toutes les lignes\r\n  db.all('SELECT * FROM afaire', function(err, result) {\r\n\r\n// fonction de rappel avec les erreurs s'il y en a et le résultat (toutes les lignes de la table)\r\n   callback(err, result)\r\n  })\r\n })\r\n\r\n// fermeture de la base\r\n db.close()\r\n}\r\n```\r\n\r\n**lire.js**\r\n\r\n```\r\nvar sqlite3 = require('sqlite3')\r\n\r\nmodule.exports = function(callback) {\r\n\r\n// ouverture de la base\r\n var db = new sqlite3.Database('bd.sqlite')\r\n\r\n// requête\r\n db.all('SELECT * FROM afaire', function(err, result) {\r\n\r\n// fonction de rappel\r\n  callback(err, result)\r\n })\r\n\r\n// fermeture\r\n db.close()\r\n}\r\n```\r\n\r\n**mise-a-jour.js**\r\n\r\n```\r\nvar sqlite3 = require('sqlite3')\r\n\r\nmodule.exports = function(d, callback) {\r\n\r\n// objet à modifier\r\n var obj = {\r\n  $id: d.id,\r\n  $text: d.text,\r\n  $fait: d.fait\r\n }\r\n\r\n// ouverture de la base\r\n var db = new sqlite3.Database('bd.sqlite')\r\n\r\n db.serialize(function() {\r\n\r\n// mise à jour\r\n  db.run('UPDATE afaire SET text=$text, fait=$fait WHERE id=$id', obj)\r\n\r\n// requête de toutes les lignes\r\n  db.all('SELECT * FROM afaire', function(err, result) {\r\n\r\n// rappel \r\n   callback(err, result)\r\n  })\r\n })\r\n\r\n// fermeture\r\n db.close()\r\n}\r\n```\r\n\r\n**supprimer.js**\r\n\r\n```\r\nvar sqlite3 = require('sqlite3')\r\n\r\nmodule.exports = function(ids, callback) {\r\n// ouverture\r\n var db = new sqlite3.Database('bd.sqlite')\r\n\r\n db.serialize(function() {\r\n\r\n// suppression \r\n// ici \"ids\" représente un dictionnaire d'\"id\" à supprimer\r\n  ids.forEach(function(id) {\r\n   db.run('DELETE FROM afaire WHERE id=$id', {$id: id})\r\n  })\r\n\r\n// requête de toutes les lignes\r\n  db.all('SELECT * FROM afaire', function(err, result) {\r\n\r\n// rappel\r\n   callback(err, result)\r\n  })\r\n })\r\n\r\n// fermeture\r\n db.close()\r\n}\r\n```\r\n\r\n**a-faire.js**\r\n\r\nDans le dossier ```lib/bd```, nous allons mettre ensemble toutes ces requêtes dans ```a-faire.js```\r\n\r\n```\r\nvar ajouter = require('./a-faire/ajouter')\r\nvar lire = require('./a-faire/lire')\r\nvar maj = require('./a-faire/mise-a-jour')\r\nvar supprimer = require('./a-faire/supprimer')\r\n\r\nexports.ajouter = function(d, callback) {\r\n ajouter(d, function(err, resp) { callback(err, resp) })\r\n}\r\nexports.lire = function(callback) {\r\n lire(function(err, resp) { callback(err, resp) })\r\n}\r\nexports.maj = function(d, callback) {\r\n maj(d, function(err, resp) { callback(err, resp) })\r\n}\r\nexports.supprimer = function(ids, callback) {\r\n supprimer(ids, function(err, resp) { callback(err, resp) })\r\n}\r\n```\r\n\r\n#### Vérifions que la base fonctionne\r\n\r\nÀ la racine du projet, créez un fichier ```verif-bd.js```\r\n\r\n```\r\nvar bd = require('./lib/bd/a-faire')\r\n \r\n// une variable pour garder l'objet ajouté\r\nvar obj\r\n\r\n// ajouter un objet\r\n\r\nbd.ajouter({text: 'Manger', fait: true}, function(err, rep) {\r\n\r\n// notifier s'il y a une erreur\r\n if(err) { console.log(err) }\r\n\r\n// sinon\r\n else {\r\n\r\n// la réponse\r\n  console.log('ajouter', rep)\r\n\r\n// garder le premier objet\r\n  obj = rep[0]\r\n }\r\n})\r\n\r\n// une seconde plus tard\r\nsetTimeout(function() {\r\n\r\n// lire\r\n bd.lire(function(err, rep) {\r\n  if(err) { console.log(err) }\r\n  else { console.log('lire', rep) }\r\n })\r\n\r\n},1000)\r\n\r\n// deux secondes plus tard\r\nsetTimeout(function() {\r\n\r\n// modifier \"obj\"\r\n obj.text = 'Dormir'\r\n\r\n// mettre à jour\r\n bd.maj(obj, function(err, rep) {\r\n  if(err) { console.log(err) }\r\n  else { console.log('mise à jour', rep) }\r\n })\r\n},2000)\r\n\r\n// trois secondes plus tard\r\nsetTimeout(function() {\r\n\r\n// un dictionnaire avec l'id de \"obj\"\r\n var aSupprimer = [obj.id]\r\n\r\n// supprimer\r\n bd.supprimer(aSupprimer, function(err, rep) {\r\n  if(err) { console.log(err) }\r\n  else { console.log('supprimer', rep) }\r\n }) \r\n},3000)\r\n```\r\n\r\nLancez le scripte:\r\n\r\n```\r\n$ node verif-bd\r\n```\r\n\r\n\r\nSi vous obtenez:\r\n\r\n```\r\najouter [ { id: 1, text: 'Manger', fait: 1 } ]\r\nlire [ { id: 1, text: 'Manger', fait: 1 } ]\r\nmise à jour [ { id: 1, text: 'Dormir', fait: 1 } ]\r\nsupprimer []\r\n```\r\n\r\nLes requêtes à la base de données fonctionnent.\r\n\r\nVous noterez que le booléen ```fait``` est ```1``` à la place de ```true``` et ```0``` à la place de ```false```. Généralement ça ne pose pas de problème du côté client. Mais j'ai remarqué que Angular, l'interprétait comme un chiffre. Pour être certains que ça marche partout, ajoutons une fonction ```arrangerBool()``` à ```lib/bd/a-faire.js```.\r\n\r\n```\r\nvar ajouter = require('./a-faire/ajouter')\r\nvar lire = require('./a-faire/lire')\r\nvar maj = require('./a-faire/mise-a-jour')\r\nvar supprimer = require('./a-faire/supprimer')\r\n\r\nexports.ajouter = function(d, callback) {\r\n ajouter(d, function(err, resp) { callback(err, arrangerBool(resp)) })\r\n}\r\nexports.lire = function(callback) {\r\n lire(function(err, resp) { callback(err, arrangerBool(resp)) })\r\n}\r\nexports.maj = function(d, callback) {\r\n maj(d, function(err, resp) { callback(err, arrangerBool(resp)) })\r\n}\r\nexports.supprimer = function(ids, callback) {\r\n supprimer(ids, function(err, resp) { callback(err, arrangerBool(resp)) })\r\n}\r\n\r\nfunction arrangerBool(dic) {\r\n dic.forEach(function(obj) {\r\n  if(obj.fait === 0) { obj.fait = false }\r\n  else { obj.fait = true }\r\n })\r\n return dic\r\n}\r\n```\r\n\r\n## Le serveur\r\n\r\nNous allons maintenant écrire le serveur qui fera le lien entre la base et les clients. À la racine du projet, créez un fichier ```serveur.js```\r\n\r\n```\r\n// Express\r\nvar express = require('express')\r\nvar app = express()\r\n\r\n// body-parser\r\nvar bodyParser = require('body-parser')\r\napp.use(bodyParser.json()) // pour lire les JSON envoyés par les clients\r\napp.use(bodyParser.urlencoded({ extended: true }));\r\n\r\n// l'accès à la base de données\r\nvar bd = require('./lib/bd/a-faire')\r\n\r\n// quand un client POST une nouvelle entrée\r\napp.post('/api/a-faire', function(req, res) {\r\n\r\n// \"req\" = requête du client\r\n// \"res\" = réponse du serveur\r\n\r\n// \"req.body\" = données reçues\r\n var d = req.body\r\n\r\n// \"bd.ajouter()\"\r\n bd.ajouter(d, function(err, rep) {\r\n\r\n// si erreur retourner le statut 500 et l'erreur\r\n  if(err) { res.status(500).send(err) }\r\n\r\n// sinon retourner la réponse de la base \"rep\" avec un statut 200\r\n  else { res.status(200).send(rep) }\r\n })\r\n})\r\n\r\n// quand un client GET toutes les entrées\r\napp.get('/api/a-faire', function(req,res) {\r\n bd.lire(function(err,rep) {\r\n  if(err) { res.status(500).send(err) }\r\n  else { res.status(200).send(rep) }\r\n })\r\n})\r\n\r\n// quand un client POST une mise à jour\r\napp.post('/api/a-faire/maj', function(req,res) {\r\n var d = req.body\r\n bd.maj(d, function(err,rep) {\r\n  if(err) { res.status(500).send(err) }\r\n  else { res.status(200).send(rep) }  \r\n })\r\n})\r\n\r\n// quand un client POST des ID à supprimer\r\napp.post('/api/a-faire/supprimer', function(req,res) {\r\n var d = req.body\r\n bd.supprimer(d, function(err,rep) {\r\n  if(err) { res.status(500).send(err) }\r\n  else { res.status(200).send(rep) }  \r\n })\r\n})\r\n\r\n// écouter\r\nvar port = 3000\r\napp.listen(port, function() { console.log('le serveur écoute sur le port ' + port) })\r\n```\r\n\r\nIl est déjà difficile d'avoir une bonne vue d'ensemble de ce fichier. Nous allons bouger les logiques de l'API dans un autre fichier. Dans ```lib```, créez un dossier ```api``` et à l'intérieur de celui-ci un fichier ```ctrl.js```.\r\n\r\n**lib/api/ctrl.js**\r\n\r\n```\r\nvar bd = require('../bd/a-faire')\r\n\r\nexports.ajouter = function(req, res) {\r\n var d = req.body\r\n bd.ajouter(d, function(err, rep) {\r\n  if(err) { res.status(500).send(err) }\r\n  else { res.status(200).send(rep) }\r\n })\r\n}\r\n\r\nexports.lire = function(req,res) {\r\n bd.lire(function(err,rep) {\r\n  if(err) { res.status(500).send(err) }\r\n  else { res.status(200).send(rep) }\r\n })\r\n}\r\n\r\nexports.maj = function(req,res) {\r\n var d = req.body\r\n bd.maj(d, function(err,rep) {\r\n  if(err) { res.status(500).send(err) }\r\n  else { res.status(200).send(rep) }  \r\n })\r\n}\r\n\r\nexports.supprimer = function(req,res) {\r\n var d = req.body\r\n bd.supprimer(d, function(err,rep) {\r\n  if(err) { res.status(500).send(err) }\r\n  else { res.status(200).send(rep) }  \r\n })\r\n}\r\n```\r\n\r\n**serveur.js**\r\n\r\n```\r\nvar express = require('express')\r\nvar app = express()\r\n\r\nvar bodyParser = require('body-parser')\r\napp.use(bodyParser.json())\r\napp.use(bodyParser.urlencoded({ extended: true }));\r\n\r\nvar apiCtrl = require('./lib/api/ctrl')\r\napp.post('/api/a-faire', apiCtrl.ajouter)\r\napp.get('/api/a-faire', apiCtrl.lire)\r\napp.post('/api/a-faire/maj', apiCtrl.maj)\r\napp.post('/api/a-faire/supprimer', apiCtrl.supprimer)\r\n\r\nvar port = 3000\r\napp.listen(port, function() { console.log('le serveur écoute sur le port ' + port) })\r\n```\r\n\r\nNous avons maintenant un serveur REST. Dans le prochain chapitre nous allons servir les clients et les adapter pour communiquer avec le serveur. Nous pouvons déja créer les URL d'accès aux clients que nous mettrons dans un dossier ```public```.\r\n\r\nIl y aura deux clients:\r\n\r\n* riot (chapitre 2)\r\n* angular (chapitre 5)\r\n\r\nL'accès au serveur se fait par le modèle, ce n'est pas la peine d'avoir les variantes \"vanilla\" et \"handlebars\" puisque c'est le même modèle qu'avec \"riot\".\r\n\r\nCréez le dossier ```public``` à la racine du projet et à l'intérieur de celui-ci un dossier par client.\r\n\r\n```\r\npublic\r\n  angular\r\n  riot\r\n```\r\n\r\nDans ```serveur.js```, ajoutez les lignes suivantes avant ```app.listen()```\r\n\r\n```\r\napp.use('/riot', express.static(__dirname + '/public/riot'))\r\napp.use('/angular', express.static(__dirname + '/public/angular'))\r\n```\r\n\r\nPour toutes les URL commençant par \"/client/riot\", express servira les fichiers du dossier ```public/riot```. Par exemple ```/client/riot/script.js``` renvoit le fichier ```/public/riot/script.js``` s'il existe.\r\n\r\nDans le prochain chapitre nous connecterons nos clients à l'API.\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}